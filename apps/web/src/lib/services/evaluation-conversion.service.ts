import type { SupabaseClient } from '@supabase/supabase-js';
import type { Database } from '@hadley-bricks/database';
import { PurchaseService } from './purchase.service';
import { InventoryService } from './inventory.service';
import type {
  PurchaseEvaluation,
  ConvertEvaluationRequest,
  ConversionResult,
} from '../purchase-evaluator/types';

export interface ConversionValidationError {
  code: 'ALREADY_CONVERTED' | 'INVALID_STATUS' | 'NO_ITEMS' | 'NOT_FOUND';
  message: string;
}

// Extended row type that includes conversion columns (added via migration)
interface EvaluationRowWithConversion {
  id: string;
  user_id: string;
  name: string | null;
  source: string | null;
  default_platform: string | null;
  total_purchase_price: number | null;
  cost_allocation_method: string | null;
  item_count: number | null;
  total_cost: number | null;
  total_expected_revenue: number | null;
  overall_margin_percent: number | null;
  overall_roi_percent: number | null;
  status: string | null;
  lookup_completed_at: string | null;
  converted_at: string | null;
  converted_purchase_id: string | null;
  created_at: string;
  updated_at: string;
}

/**
 * Service for converting purchase evaluations into purchases and inventory items.
 */
export class EvaluationConversionService {
  private supabase: SupabaseClient<Database>;
  private userId: string;
  private purchaseService: PurchaseService;
  private inventoryService: InventoryService;

  constructor(supabase: SupabaseClient<Database>, userId: string) {
    this.supabase = supabase;
    this.userId = userId;
    this.purchaseService = new PurchaseService(supabase, userId);
    this.inventoryService = new InventoryService(supabase, userId);
  }

  /**
   * Validate that an evaluation can be converted
   */
  async validateConversion(evaluationId: string): Promise<ConversionValidationError | null> {
    // Fetch evaluation - using raw query to handle new columns
    const { data, error } = await this.supabase
      .from('purchase_evaluations')
      .select('*')
      .eq('id', evaluationId)
      .eq('user_id', this.userId)
      .single();

    if (error || !data) {
      return { code: 'NOT_FOUND', message: 'Evaluation not found' };
    }

    // Cast to extended type
    const evaluation = data as unknown as EvaluationRowWithConversion;

    // Check if already converted
    if (evaluation.status === 'converted' || evaluation.converted_at) {
      return {
        code: 'ALREADY_CONVERTED',
        message: 'This evaluation has already been converted to a purchase',
      };
    }

    // Check if in a valid state for conversion
    if (evaluation.status !== 'completed' && evaluation.status !== 'saved') {
      return {
        code: 'INVALID_STATUS',
        message:
          'Evaluation must be completed or saved before converting. Please finish the price lookups first.',
      };
    }

    // Check if there are items
    if (!evaluation.item_count || evaluation.item_count === 0) {
      return { code: 'NO_ITEMS', message: 'Cannot convert an evaluation with no items' };
    }

    return null; // Valid
  }

  /**
   * Convert an evaluation to a purchase and inventory items
   */
  async convert(evaluationId: string, input: ConvertEvaluationRequest): Promise<ConversionResult> {
    // Validate first
    const validationError = await this.validateConversion(evaluationId);
    if (validationError) {
      throw new Error(validationError.message);
    }

    // Create the purchase
    const purchase = await this.purchaseService.create({
      purchase_date: input.purchase.purchase_date,
      short_description: input.purchase.short_description,
      cost: input.purchase.cost,
      source: input.purchase.source,
      payment_method: input.purchase.payment_method,
      reference: input.purchase.reference,
      description: input.purchase.description,
    });

    // Create inventory items with purchase link
    const inventoryItemsData = input.inventoryItems.map((item) => ({
      set_number: item.set_number,
      item_name: item.item_name || null,
      condition: item.condition,
      status: item.status || 'NOT YET RECEIVED',
      source: item.source || null,
      purchase_date: input.purchase.purchase_date,
      purchase_id: purchase.id,
      cost: item.cost,
      listing_value: item.listing_value,
      listing_platform: item.listing_platform || null,
      storage_location: item.storage_location || null,
      amazon_asin: item.amazon_asin || null,
      sku: item.sku || null, // Will be auto-generated by InventoryService
      notes: item.notes || null,
    }));

    const inventoryItems = await this.inventoryService.createMany(inventoryItemsData);

    // Update evaluation status to converted using raw update to handle new columns
    const { data: updatedData, error: updateError } = await this.supabase
      .from('purchase_evaluations')
      .update({
        status: 'converted',
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        converted_at: new Date().toISOString() as any,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        converted_purchase_id: purchase.id as any,
      } as Database['public']['Tables']['purchase_evaluations']['Update'])
      .eq('id', evaluationId)
      .eq('user_id', this.userId)
      .select('*')
      .single();

    if (updateError) {
      // Log but don't fail - the conversion succeeded, just the status update failed
      console.error(
        '[EvaluationConversionService] Failed to update evaluation status:',
        updateError
      );
    }

    // Return the result
    return {
      purchase: {
        id: purchase.id,
        short_description: purchase.short_description,
        cost: purchase.cost,
        purchase_date: purchase.purchase_date,
      },
      inventoryItemCount: inventoryItems.length,
      evaluation: updatedData
        ? this.mapEvaluationRow(updatedData as unknown as EvaluationRowWithConversion)
        : await this.getEvaluation(evaluationId),
    };
  }

  /**
   * Get a single evaluation
   */
  private async getEvaluation(evaluationId: string): Promise<PurchaseEvaluation> {
    const { data, error } = await this.supabase
      .from('purchase_evaluations')
      .select('*')
      .eq('id', evaluationId)
      .eq('user_id', this.userId)
      .single();

    if (error || !data) {
      throw new Error('Failed to fetch evaluation');
    }

    return this.mapEvaluationRow(data as unknown as EvaluationRowWithConversion);
  }

  /**
   * Map database row to PurchaseEvaluation type
   */
  private mapEvaluationRow(row: EvaluationRowWithConversion): PurchaseEvaluation {
    // Type assertion for new columns that may not be in the DB types yet
    const extendedRow = row as unknown as Record<string, unknown>;

    return {
      id: row.id,
      userId: row.user_id,
      name: row.name,
      source: row.source,
      defaultPlatform: (row.default_platform as 'amazon' | 'ebay') || 'amazon',
      totalPurchasePrice: row.total_purchase_price,
      costAllocationMethod: row.cost_allocation_method as
        | 'per_item'
        | 'proportional'
        | 'equal'
        | null,
      itemCount: row.item_count ?? 0,
      totalCost: row.total_cost,
      totalExpectedRevenue: row.total_expected_revenue,
      overallMarginPercent: row.overall_margin_percent,
      overallRoiPercent: row.overall_roi_percent,
      status:
        (row.status as 'draft' | 'in_progress' | 'completed' | 'saved' | 'converted') || 'draft',
      lookupCompletedAt: row.lookup_completed_at,
      convertedAt: row.converted_at ?? null,
      convertedPurchaseId: row.converted_purchase_id ?? null,
      // Photo evaluation fields - these columns may not exist in DB yet until migration is applied
      evaluationMode: (extendedRow.evaluation_mode as 'cost_known' | 'max_bid') ?? 'cost_known',
      targetMarginPercent: (extendedRow.target_margin_percent as number | null) ?? null,
      photoAnalysisJson:
        (extendedRow.photo_analysis_json as Record<string, unknown> | null) ?? null,
      listingDescription: (extendedRow.listing_description as string | null) ?? null,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    };
  }
}
